# Odatav4. Quickstart.
Итак, начать делать сервис можно как обычно в транзакции `SEGW` или сделать сервис полностью вручную, а затем его опубликовать. Еще можно использовать RESTful Application Programming (RAP) Model, но последний подход не реализован в SAP в версии 750, поэтому здесь рассматриваться не будет.
# Начало.
## Создание сервиса через segw
В транзакции `SEGW` жмем **Create project** и заполняем название/описание, в project type выбираем загадочное 4, в generation strategy выбираем 1 - Standard OData 4.0.
![segw_create.png](https://github.com/Via04/odatav4-guide/blob/master/static/segw_create.png)

При выборе появится предупреждение с нотой.
![segw_warn.png](https://github.com/Via04/odatav4-guide/blob/master/static/segw_warn.png)

Суть в том, что нас предупреждают, что начиная с текущей версии (750) `SEGW` является legacy способом создания сервисов и лучше либо полностью с нуля реализовывать сервис (потому что таким образом можно полностью через eclipse разрабатывать сервис) либо через RAP. В нашем случае можно смело это предупреждение игнорировать, но тем не менее, ниже я расскажу, как создать сервис без `SEGW`.  
Итак, мы получаем в `SEGW` сервис. Принципы работы с таким сервисом в основном схоже с odatav2. Главным отличием является создание Navigation Property. Теперь ассоциации исчезли и связь между типами устанавливается напрямую в Navigation Property, а тип связи контролируется двумя галочками Collection и Nullable (см. скриншот ниже).
![nav_prop.png](https://github.com/Via04/odatav4-guide/blob/master/static/nav_prop.png)

Из названия понятно за что они отвечают, но ниже будет показано подробно.  
Для любого типа независимо от его отношений, всегда создается EntitySet. В этом плане odata v4 можно рассматривать как язык программирования, по аналогии с ABAP, мы определяем тип, а затем создаем переменную в виде сущности этого типа.  
Итак допустим мы создали сервис и сгенерировали, теперь данный сервис нужно опубликовать в сервисную группу, а группу сделать доступной (аналогично тому, как это делается в /iwfnd/maint_service).
## Создание сервиса через /iwbep/v4_admin
Для того, чтобы создать сервис напрямую без `SEGW` и избежать предупреждения, нужно самому создать и реализовать два класса:
1. **Model** класс - наследуется от абстрактного `/IWBEP/CL_V4_ABS_MODEL_PROV` и нужен для создания модели данных oData (MPC по простому)
2. **Data provider** класс - наследуется от абстрактного `/IWBEP/CL_V4_ABS_DATA_PROVIDER` и нужен для описания бизнес логики работы сервиса (DPC по простому)

Классы \*MPC и \*DPC генерируемые `segw` ничем не отличаются, поэтому, в целом, можно уверенно использовать `segw` для создания сервисов. Но не все можно сделать в `segw` поэтому для унификации подхода к реализации возможно действительно лучше весь сервис целиком реализовывать через код. Подробней про работу `segw` с odatav4 и про реализацию классов для ручного создания сервиса будет в следующих параграфах.   
Теперь из этих двух классов нужно создать сервис - для этого переходим в транзакцию `/iwbep/v4_admin` и жмем кнопку **Register Service**. Вписываем имя сервиса, версию сервиса (для того, чтобы можно было иметь несколько реализаций \*DPC класса для версионности API), созданный класс-модель, созданный класс-провайдер, описание и пакет для сервиса. Далее нам сразу предложат определить сервис в группу либо определяем сразу, либо позже, нажав нет. Тогда сервис попадет в группу по-умолчанию (/iwbep/all).  
Подробней об этом в [следующем параграфе](#публикация-сервиса).
## Публикация сервиса.
Для того, чтобы опубликовать сервис нужны две транзакции:
- `/iwbep/v4_admin` - для создания групп и регистрации сервисов в группы (также через нее можно регистрировать сервисы созданные вручную).
- `/iwfnd/v4_admin` - для публикации групп (аналогично `/iwfnd/maint_service`).

Сервисы, которые только были созданы, попадают в **Default Service group /IWBEP/ALL**. Сами эти группы нужны для управления доступом к сервису, на запуск сервисов из каждой сервисной группы нужны полномочия объекта **S_START** с полями **R4TR G4BA group_id**.
Итак, у нас есть сервис, для ограничения доступа к нему (ну и предоставления, сервисы из группы ALL по-умолчанию не опубликованы) создадим свою группу в `/iwbep/v4_admin` с помощью кнопки **Register Group** (см. ниже на скриншоте).
![def_group.png](https://github.com/Via04/odatav4-guide/blob/master/static/def_group.png)

Теперь в свою группу определим сервис. Кнопка **Assign Service**.
![assign_serv.png](https://github.com/Via04/odatav4-guide/blob/master/static/assign_serv.png)

Вписываем созданную группу и имя сервиса, репозиторий в случае нашей системы (750) всегда будет DEFAULT, другие варианты соответственно для сервисов, разработанных через SADL и RAP.

Теперь созданную группу нужно опубликовать через `/iwfnd/v4_admin`. Жмем кнопку **Publish Service Groups**.
![pub_serv.png](https://github.com/Via04/odatav4-guide/blob/master/static/pub_serv.png)

- **System Alias** - аналогично `/iwfnd/maint_service`, в нашем случае почти всегда LOCAL
- **Service Group** - имя нашей группы

Вписываем и жмем кнопку **Get Service Groups**. На экране появятся подробности по группе, првоеряем, что все верно выделяем запись с группой и жмем кнопку **Publish Service Groups**:
![pub_serv_1.png](https://github.com/Via04/odatav4-guide/blob/master/static/pub_serv_1.png)

В появившемся окне вписываем имя публикации:
![assign_serv_2.png](https://github.com/Via04/odatav4-guide/blob/master/static/assign_serv_2.png)

И далее указываем запрос. В принципе, на этом этапе создание/публикация сервиса закончена и теперь сервис можно тестировать через `/iwfnd/gw_client`. Для того, чтобы быстро перейти в `/iwfnd/gw_client` для тестирования сервиса, вернемся на главный экран транзакции `/iwfnd/v4_admin`. Слева выберем наш новый сервис и нажмем кнопку **Service Implementation** на вкладке Available Services:
![nav_serv.png](https://github.com/Via04/odatav4-guide/blob/master/static/nav_serv.png)

Мы попадем в транзакцию `/iwbep/v4_admin` с уже выбранной нашей группой, жмем кнопку **Service Test** (в выпадающем списке можно выбрать где открыть в браузере или в GW_CLIENT, но по-умолчанию выбирается последний) на тулбаре сервиса, затем выбираем настроенный алиас и попадаем в классический `/iwfnd/gw_client` с уже вписанным URI для получения metadata сервиса. На этом создание сервиса завершено.
# oDatav4 framework
## oDatav4 Model
Реализация \*MPC классов в oDatav4 во многом похожа на oDatav2 поэтому я не буду здесь полностью расписывать как создать модель, наследуясь от класса `/IWBEP/CL_V4_ABS_MODEL_PROV`, а пройдусь только по неочевидным нюансам. К тому же, почти наверняка, модель всегда будет создаваться из транзакции `segw`. Но для общего понимания, а также для решения проблем, которые в `segw` нерешаемы, написан это параграф.  
Итак для создания модели, отнаследовавшись от класса `/IWBEP/CL_V4_ABS_MODEL_PROV` нужно переопределить метод `define`. Во входящем параметре `io_model` будут все необходимые методы для описания модели. Хороший пример реализации модели можно посмотреть в стандартном демо классе `/iwbep/cl_v4_tea_busi_pr_model`. Рассмотрим пару неочевидных примеров.
### Сущность для прикрепления документов
В oDatav2 для прикрепления документов был специальный тип сущности EDM.Stream (галка media в segw), он же есть и в odatav4, однако entity type типа EDM.Stream создать в odatav4 нельзя, зато можно создать отдельно поле типа EDM.Stream. Допустим мы создали Complex Type *Attachment* в `segw`, по-умолчанию в `segw` нет типа поля EDM.Stream, но его можно указать вручную внутри кода для модели. Код из имплементации метода `/iwbep/if_v4_mp_basic~define`:
```abap
DATA lo_prop TYPE REF TO /iwbep/if_v4_med_prim_prop.
DATA(lo_complex_type) = io_model->get_complex_type( iv_complex_type_name = 'ATTACHMENT' ).
lo_prop ?= lo_complex_type->get_property( iv_property_name = 'CONTENT' ).
lo_prop->set_content_type_property( 'FILETYPE' ).
lo_prop->set_file_name_property( 'FILENAME' ).
lo_prop->set_value_control_property( 'VAL_CTL' ).
lo_prop->set_edm_type( /iwbep/if_v4_med_element=>gcs_edm_data_types-stream ).
lo_prop->set_is_nullable( ).
lo_prop ?= lo_complex_type->get_property( 'FILETYPE' ).
lo_prop->set_is_technical( ).
lo_prop ?= lo_complex_type->get_property( 'FILENAME' ).
lo_prop->set_is_technical( ).
lo_prop ?= lo_complex_type->get_property( 'VAL_CTL' ).
lo_prop->set_is_technical( ).
lo_prop ?= lo_complex_type->get_property( 'LENGTH' ).
lo_prop->set_is_technical( ).
```
Здесь из модели получается созданный ранее в \*MPC комлексный тип **ATTACHMENT**, затем из него достается поле **CONTENT**. Для этого поля указываются технические поля, где будет длина файла, имя контрольный флаг для удаления и mime тип. Далее для каждого технического поля указывается явно, что оно техническое, чтобы они не мелькали в теле запроса для сущности с данным комплексным типом.
## oDatav4 Data provider
Прежде, чем мы перейдем к примерам кода и реализации сервиса, сначала важно понять общий принцип работы фреймворка, поэтому сначала в двух словах я расскажу, как устроен абстрактный класс `/IWBEP/CL_V4_ABS_DATA_PROVIDER` отвечающий за реализацию логики сервиса.  
Фреймворк состоит из 3 уровней-интерфейсов, которые вызываются последовательно друг из друга и на каждом уровне реализация все менее "абстрактная".
* `/IWBEP/IF_V4_DP_BASIC` - Самый базовый user-friendly интерфейс, который подходит в 90% процентов случаев. Все операции CRUD, а также `READ_REF_TARGET_KEY` для expand (подробности дальше)
* `/IWBEP/IF_V4_DP_INTERMEDIATE` - Переопределенные методы отсюда позволяют создать свою реализацию expand (только для READ операций) аналог GET_EXPANDED_ENTITY в odatav2, обработка PATCH, обработка etag (концепт блокировки на уровне api, подобно саповским блокировкам)
* `/IWBEP/IF_V4_DP_ADVANCED` - Самый низкоуровневый интерфейс, любой запрос сначала попадает в него, содержит все те же CRUD методы, однако переализация методов этого интерфейса прерывает стандартную обработку фреймворка, позволяя таким образом например в переопределении метода `create_entity` создавать deep entity по аналогии с odatav2. Хотя классический концепт фреймворка предполагает, что создание, чтение и обновление сущностей по каскаду будет производиться с помощью их *basic* методов, а для операций над каскадами (expand) будет использоваться метод `READ_REF_TARGET_KEY` с заданием соотвествующих ключей для создания, чтения или обновления дочерних сущностей, для оптимизации можно переопределить соответствующие методы *advanced* интерфейса.  
Итак, таким образом, фреймворк odatav4 работает следующим образом сначала в абстрактном классе `/IWBEP/CL_V4_ABS_DATA_PROVIDER` решается, какой метод CRUD был вызван и в зависимости от этого вызывается соответствующий метод *advanced* интерфейса, затем если тот метод не переопределен, проводится стандартная обработка запроса и вызываются более высокоуровневые методы соответственно *intermediate* и *basic* интерфейса.  
